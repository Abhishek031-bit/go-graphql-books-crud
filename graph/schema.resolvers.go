package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.78

import (
	"context"
	"go-graphql/database"
	"go-graphql/graph/model"
	"go-graphql/models"
	"strconv"
)

func (r *mutationResolver) CreateBook(ctx context.Context, input model.NewBook) (*model.Book, error) {
	book := &models.Book{
		Title:  input.Title,
		Author: input.Author,
	}
	if err := database.DB.Create(&book).Error; err != nil {
		return nil, err
	}
	return ConvertToGraphQLBook(book), nil
}

func (r *mutationResolver) UpdateBook(ctx context.Context, id string, input model.NewBook) (*model.Book, error) {
	var book models.Book
	if err := database.DB.First(&book, id).Error; err != nil {
		return nil, err
	}
	book.Title = input.Title
	book.Author = input.Author
	if err := database.DB.Save(&book).Error; err != nil {
		return nil, err
	}
	return ConvertToGraphQLBook(&book), nil
}

func (r *mutationResolver) DeleteBook(ctx context.Context, id string) (bool, error) {
	idInt, _ := strconv.Atoi(id)
	if err := database.DB.Delete(&models.Book{}, idInt).Error; err != nil {
		return false, err
	}
	return true, nil
}

func (r *queryResolver) Books(ctx context.Context) ([]*model.Book, error) {
	var books []*models.Book
	if err := database.DB.Find(&books).Error; err != nil {
		return nil, err
	}
	var gqlBooks []*model.Book
	for _, b := range books {
		gqlBooks = append(gqlBooks, ConvertToGraphQLBook(b))
	}
	return gqlBooks, nil
}

func (r *queryResolver) Book(ctx context.Context, id string) (*model.Book, error) {
	var book models.Book
	if err := database.DB.First(&book, id).Error; err != nil {
		return nil, err
	}
	return ConvertToGraphQLBook(&book), nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
